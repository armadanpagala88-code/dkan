<?php

/**
 * @file
 * Defines a multi-field form element based on a JSON Schema.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\file\Entity\File;
use Drupal\json_form_widget\Plugin\Field\FieldWidget\JsonFormWidget;
use Drupal\json_form_widget\ArrayHelper;
use Drupal\json_form_widget\Element\UploadOrLink;

/**
 * Submit handler for the "add-one-more" button.
 *
 * Increments the max counter and causes a rebuild.
 */
function json_form_widget_add_one(array &$form, FormStateInterface $form_state): void {
  _json_form_widget_update_count($form_state, 1);
}

/**
 * Submit handler for the "remove one" button.
 *
 * Decrements the max counter and causes a form rebuild.
 */
function json_form_widget_remove_one(array &$form, FormStateInterface $form_state): void {
  _json_form_widget_update_count($form_state, -1);
}

/**
 * Update count property by the given offset.
 *
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   Form state.
 * @param int $offset
 *   Offset to change count by.
 */
function _json_form_widget_update_count(FormStateInterface $form_state, int $offset): void {
  // Build count property form state attribute.
  $button_element = $form_state->getTriggeringElement();
  $count_property = _json_form_widget_build_count_property($button_element);
  // Modify stored item count.
  $item_count = $form_state->get($count_property) ?? 0;
  $item_count += $offset;
  $form_state->set($count_property, $item_count);

  // Since our buildForm() method relies on the value of 'num_names' to
  // generate 'name' form elements, we have to tell the form to rebuild. If we
  // don't do this, the form builder will not call buildForm().
  $form_state->setRebuild();
}

/**
 * Build count property form state attribute.
 *
 * @param array $form_button_element
 *   Form button element.
 *
 * @return string[]
 *   Form element context.
 */
function _json_form_widget_build_count_property(array $button_element): array {
  $field_context = $button_element['#attributes']['data-context'];
  return ArrayHelper::buildCountProperty($field_context);
}

/**
 * Implements hook_field_widget_complete_form_alter().
 *
 * Set json_form_widget flag for later.
 */
function json_form_widget_field_widget_complete_form_alter(&$field_widget_complete_form, FormStateInterface $form_state, $context) {
  if ($context['widget'] instanceof JsonFormWidget) {
    $form_state->set('has_json_form_widget', TRUE);
  }
}

/**
 * Implements hook_form_alter().
 *
 * Add custom submit handler to form if it contains an upload_or_link element.
 *
 * @todo This seems like it should not be necessary. How else can we get
 * UploadOrLink::submit to execute on the form submit, or avoid this?
 */
function json_form_widget_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (!isset($form['actions']['submit'])) {
    return;
  }
  if ($form_state->get('has_json_form_widget')) {
    $form['actions']['submit']['#submit'][] = [UploadOrLink::class, 'submit'];
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Clean up file usage after entity delete.
 */
function json_form_widget_entity_delete(EntityInterface $entity) {
  $type = $entity->getEntityTypeId();
  $id = $entity->id();

  // Find files by entity/module usage.
  $fids = \Drupal::database()->select('file_usage', 'fu')
    ->fields('fu', ['fid'])
    ->condition('fu.type', $type)
    ->condition('fu.id', $id)
    ->condition('fu.module', 'json_form_widget')
    ->execute()
    ->fetchCol();

  $files = File::loadMultiple($fids);

  // Remove one usage for each file related to deleted entity.
  foreach ($files as $file) {
    \Drupal::service('file.usage')->delete($file, 'json_form_widget', $type, $id);
  }

}

/**
 * Implements hook_preprocess_HOOK() for json_form_widget_file_link.
 */
function json_form_widget_preprocess_file_link(array &$variables) {
  $file = $variables['file'];
  if (!$file instanceof File) {
    return;
  }
  // Find out if file has json_form_widget usage.
  $usage = \Drupal::service('file.usage')->listUsage($file);
  $jfw_usage = FALSE;
  foreach (array_keys($usage) as $type) {
    if ($type == 'json_form_widget') {
      $jfw_usage = TRUE;
      break;
    }
  }
  // If it does, and the URI does not start with public://, show the full URL as
  // the link title. Otherwise, show the file name.
  if ($jfw_usage && (strpos($file->getFileUri(), 'public://') !== 0) && isset($variables['link'])) {
    unset($variables['file_size']);
    $variables['link']['#title'] = $file->getFileUri();
  }
}
